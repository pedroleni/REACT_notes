# HOC ReactJS

Introducci√≥n

---

Explicaremos uno de los patrones m√°s conocido a la hora de crear aplicaciones escalables y mantenibles con una correcta organizaci√≥n del c√≥digo. El concepto que vas a aprender le llamamos HOC, que para entendernos ser√≠a un "componente de orden superior".

Para definir un HOC, podr√≠amos decir que se trata de un componente cuya √∫nica labor es la de envolver a otro componente y devolverlo de forma consistente, pero a√±adiendo un comportamiento adicional de forma controlada y esperable. Por as√≠ decirlo, a√±ade funcionalidad en un nivel intermedio entre el que ser√≠a el "parent component" y un "child component" de forma que podremos abstraer l√≥gica y no llenar nuestros componentes de condiciones ‚ú®.

**Creaci√≥n de un HOC**

---

Ahora que tenemos la definici√≥n de lo que es un HOC, vamos a verlo en c√≥digo para entener el concepto y aprender a usarlo en las situaciones necesarias.

Lo primero que tienes que tener en cuenta es que un HOC se llamar√° normalmente con la palabra¬†`With`¬†seguido de la funcionalidad que estamos a√±adiendo, por ejemplo, un HOC que hace un console.log con el nombre del componente que envuelve, se llamar√≠a¬†`WithComponentNameLog`:

```jsx
const WithComponentNameLog = (Component) => {
  console.log('HOC invocado con el componente:', Component.name);

  return (props) => {
    return <Component {...props} />;
  };
};
```

Como puedes ver, aqu√≠ tenemos un concepto muy importante en marcha, la currificaci√≥n de nuestros componentes, lo que trataremos en otro art√≠culo hablando del concepto¬†`curry`¬†en JavaScript. En resumen, esto consiste en crear funciones que al ser invocadas devuelven otra funci√≥n lista para invocarse üéÅ.

Si analizamos este caso encontramos lo siguiente:

1. La funci√≥n¬†`WithComponentNameLog`¬†recibe un¬†`Component`¬†como argumento.
2. Hace un¬†`console.log`¬†con el nombre del componente nombre al ser invocada por primera vez.
3. Devuelve un nuevo componente intermedio que a su vez devuelve a¬†`Component`¬†con los props que se le pasan al componente intermedio.

Parece una locura as√≠ de primeras, pero este tipo de conceptos es muy bueno conocerlos para ocasiones futuras y seguramente lo encuentres aplicado en multitud de proyectos, vamos a ver el uso de este HOC en pr√°ctica.

Tendremos un archivo¬†`hocs/WithComponentNameLog.jsx`¬†que exporta el HOC que hemos creado:

```jsx
// Tenemos un HOC que al ser invocado hace un log con el nombre del componente
const WithComponentNameLog = (Component) => {
  console.log('HOC invocado con el componente:', Component.name);

  return (props) => {
    return <Component {...props} />;
  };
};

export default WithComponentNameLog;
```

Tendremos un archivo¬†`components/HomePage.jsx`¬†que exporta un componente¬†`HomePage`¬†muy sencillo:``

```jsx
// Tenemos un componente HomePage que queremos envolver en el HOC
const HomePage = () => <h1>Home üè†</h1>;

export default HomePage;
```

Y por √∫ltimo en¬†`App.jsx`¬†vamos a importar todo y a generar un componente¬†`HomePage` ¬†vitaminado con ayuda del HOC:

```jsx
import HomePage from './components/HomePage';
import WithComponentNameLog from './hocs/WithComponentNameLog';

// Siempre FUERA DEL RENDER de un componente, envolvemos al componente que queremos en un HOC
const HomeWithLog = WithComponentNameLog(HomePage);

const App = () => {
  return (
    <div className="App">
      {/* Ahora podemos invocar al componente HomeWithLog directamente como si fuese HomePage */}
      <HomeWithLog />
    </div>
  );
};
```

Y esta ser√≠a la forma de utilizar un HOC, la l√≠nea en la que lo invocamos pas√°ndole el componente que queremos envolver, se invocar√° a su vez la primera parte de la funci√≥n¬†`WithComponentNameLog`¬†y esto har√° que veamos por consola:

```jsx
HOC invocado con el componente HomeWithLog
```

**Casos de uso**

---

Vale, ahora que has visto en qu√© consiste un HOC y la forma de aplicarlos, vamos a ver un caso de uso real que tenga bastante m√°s sentido que el HOC que hace¬†`console.log`¬†que acabamos de ver üòÇ.

Imagina que tienes tu web personal llena de secciones con t√≠tulos y descripciones, y has creado una animaci√≥n por medio de CSS para que √∫nicamente las secciones que tu quieras cambien de colores como un arcoiris üåà.

```css
.color-swap {
  animation-name: colorSwap;
  animation-duration: 1000ms;
}

@keyframes colorSwap {
  0% {
    color: red;
  }
  25% {
    color: orange;
  }
  50% {
    color: yellow;
  }
  75% {
    color: grey;
  }
  100% {
    color: white;
  }
}
```

Ahora tienes que elegir entre:

- Aplicar este¬†`className`¬†a mano en cada secci√≥n que quieras, envolviendo todo en un¬†`div`¬†al que aplicar la clase y a√±adiendo una l√≥gica a cada componente que realmente no querr√≠as gestionar en ese punto.
- Crear un HOC que gestione esta l√≥gica sobre tus componentes sin alterarlos, teniendo un √∫nico punto de influencia localizado.

Como te puedes imaginar, la segunda opci√≥n es la m√°s viable a largo plazo, as√≠ que vamos a crear un HOC llamado¬†`WithColorSwap`:

```jsx
export const WithColorSwap = (Component) => (props) => {
  return (
    <div className="color-swap">
      <Component {...props} />
    </div>
  );
};
```

O su versi√≥n con TypeScript (ya sabes que aqu√≠ nos encanta TS) para que veas como crear HOCs con tipos gen√©ricos:``

```jsx
export const WithColorSwap =
  <T extends {}>(Component: (props: T) => JSX.Element) =>
  (props: T) => {
    return (
      <div className="color-swap">
        <Component {...props} />
      </div>
    );
  };
```

Como habr√°s podido observar aqu√≠, este HOC es muy sencillo y lo que hace es devolver un componente envuelto en un¬†`div`¬†con la clase¬†`color-swap`¬†aplicada. Podr√≠a tener algo m√°s de l√≥gica para aplicar la clase cuando el componente entre en pantalla para tener transiciones muy din√°micas, pero para este ejemplo no queremos complicar m√°s la cosa üò±

El HOC se usar√≠a de la siguiente forma:

```jsx
import './App.css'
import { WithColorSwap } from './components/WithColorSwap'

// 1. Componente Section que recibe un t√≠tulo y una descripci√≥n, reusable:
const Section = ({ title, description }) => {
  return (
    <section>
      <h1>{title}</h1>
      <p>{description}</p>
    </section>
  );
};

// 2. Creamos un nuevo componente ColorSwapSection que tiene el HOC aplicado a Section
const ColorSwapSection = WithColorSwap(Section);

export default function App() {
  return (
    <div className="App">
      {/** 3. Podemos usar el componente en App como si fuese Section, pero con la animaci√≥n aplicada: **/}
      <ColorSwapSection
        title="Coding"
        description="Aprendiendo HOC üöÄ"
      />
    </div>
  );
}
```

Y esto se podr√≠a aplicar a tantos componentes como queramos sin modificar su l√≥gica interna, ver√≠amos lo siguiente en nuestra web:

![HOC.gif](HOC%20ReactJS%201d6f265f3abc4b02a218595343a67ab1/HOC.gif)

**Consideraciones sobre los HOCs**

---

Ahora que has visto un caso de uso real, habr√°s podido observar varias cosas importantes:

- Un HOC puede ser sustituido por un componente que envuelva a nuestro componente sin necesidad de tener funciones currificadas, si te resulta m√°s c√≥moda esta forma de aplicar l√≥gica a tus componentes, no dudes en utilizarla:

```jsx
const WithColorSwap = ({ children }) => {
  return <div className="color-swap">{children}</div>;
};

// Lo usar√≠amos de la siguiente forma, como un componente normal:
export default function App() {
  return (
    <div className="App">
      <WithColorSwap>
        <Section
          title="Coding"
	        description="Aprendiendo HOC üöÄ"
        />
      </WithColorSwap>
    </div>
  );
}
```

- Desde que existen los HOOKS en react, podemos crear¬†Custom Hooks¬†para aplicar parte de est√° l√≥gica en algunos casos, no dudes en usar patrones que manejes mejor si tienes alternativas üöÄ.
- Un HOC debe ser una funci√≥n lo m√°s pura posible, es decir, para un mismo¬†`input`¬†en las mismas condiciones, debes devolver siempre el mismo output. Si tu HOC a√±ade l√≥gica que depende de un contexto por ejemplo, debes documentarlo correctamente o indicarlo en su nombre.
- Si quieres usar un state o alg√∫n HOOK dentro de la segunda funci√≥n de un HOC, debes crear esa segunda funci√≥n por separado para mejorar la legibilidad, a continuaci√≥n te dejamos un ejemplo bonus (muy √∫til por cierto) para que lo veas aplicado.

Y recuerda , este tipo de pr√°cticas y patrones de desarrollo deben aplicarse siempre y cuando el equipo con el que trabajas entienda por qu√© y c√≥mo se aplican, siempre hay alternativas para todas las soluciones que planteamos, por lo que el camino adecuado para tener un proyecto escalable y f√°cil de mantener es estar de acuerdo con el equipo en qu√© pr√°cticas aplicamos.

**HOC: Rutas protegidas**

---

Te dejamos aqu√≠ un √∫ltimo HOC pensado para tener rutas protegidas en React Router v6. Est√° simplificado y no gestiona estados como la carga de datos del usuario, por lo que tendr√°s que ampliarlo si quieres tener la funcionalidad completa.

Como te hemos comentado antes, si un HOC va a utilizar un HOOK en su interior, necesita tener la segunda funci√≥n separada como si fuese un componente para mejorar su comprensi√≥n y lectura. Este HOC se conectar√° a un¬†`Context AuthContext`¬†para cargar un valor `authenticated`¬†que ser√° un booleano, y nos indicar√° si el usuario est√° o no est√° logeado. En caso negativo, har√° una redirecci√≥n a la raiz de nuestra web (podr√≠amos ampliarlo por medio de props).

Definimos primero un contexto para gestionar la autenticaci√≥n:

```jsx
import { createContext } from 'react';

export const AuthContext = createContext(false);
```

Ahora creamos un HOC¬†`WithAuthentication`¬†que proteja nuestras rutas cuando lo apliquemos:

```jsx
import { useContext } from 'react';
import { Navigate } from 'react-router-dom';
import { AuthContext } from '../contexts/AuthContext';

const WrappedComponent = (props) => {
  console.log(props)
  const { Component } = props;
  const authenticated = useContext(AuthContext);

  return authenticated ? <Component {...props} /> : <Navigate to="/" />;
};

// HOC para permitir el paso a un componente si estamos autenticados
// HOC para permitir el paso a un componente si estamos autenticados
export const WithAuthentication = (Component) => (props) => {
  return <WrappedComponent {...props} Component={Component} />;
};
```

Y por √∫ltimo, a√±adimos la l√≥gica de React Router en¬†`App`¬†y aplicamos el HOC a los componentes de que queramos tener en rutas protegidas:

```jsx
import './App.css'
import { BrowserRouter, Route, Routes } from 'react-router-dom';
import { AuthContext } from './context/AuthContext';
import { WithAuthentication } from './hocs/WithAuthentication';
import Home from './pages/Home';
import Profile from './pages/Profile';

// Componente Profile envuelto por el HOC
const AuthProfile = WithAuthentication(Profile);

export default function App() {
  return (
    <div className="App">
      {/* üö® Cambia este valor entre true/false para probar la ruta protegida üö® */}
      <AuthContext.Provider value={true}>
        <BrowserRouter>
          <Routes>
            <Route index element={<Home />} />

            {/* Usamos una ruta normal, pero con el componente protegido */}
            <Route path="profile" element={<AuthProfile />} />
          </Routes>
        </BrowserRouter>
      </AuthContext.Provider>
    </div>
  );
}
```

Ahora podremos probar la ruta protegida cambiando el valor que proveemos en¬†`App` al¬†`AuthContext.Provider`¬†y veremos como somos redirigidos a la¬†`Home`¬†de la aplicaci√≥n si no tenemos autenticaci√≥n:

![hocsProtectedRoutes.gif](HOC%20ReactJS%201d6f265f3abc4b02a218595343a67ab1/hocsProtectedRoutes.gif)

Mini-Ejercicio

---

Crea m√°s p√°ginas y un formulario para cambiar el `flag` de `false` a true dependiendo si el usuario est√° loggeado y aprovecha todo el potencial de lo aprendido para proteger tus rutas.